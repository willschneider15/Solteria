/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
import { PublicKey } from "@solana/web3.js";
import semver from "semver";
import { z } from "zod";
import { IDL } from "./xnft";
// =================
// ABSTRACTION TYPES
// =================
export const KindOptions = IDL.types[4].type.variants.map(v => v.name);
console.assert(IDL.types[4].type.variants.map(v => v.name).includes("App"));
export const TagOptions = IDL.types[5].type.variants.map(v => v.name);
console.assert(IDL.types[5].type.variants.map(v => v.name).includes("Defi"));
// =========================
// MANIFEST SCHEMA AND TYPES
// =========================
export const VersionSchema = z
    .custom()
    .refine(val => semver.valid(val) !== null, {
    message: "Invalid semantic version",
    path: ["version"],
});
export const ManifestHistorySchema = z.object({ version: VersionSchema, uri: z.string() }).array();
export const ScreenshotsSchema = z
    .object({
    uri: z.string(),
    type: z.string(),
})
    .array();
export const ImageSizeOptionsSchema = z
    .object({
    sm: z.string(),
    md: z.string(),
    lg: z.string(),
})
    .strict()
    .partial()
    .refine(({ sm, md, lg }) => sm !== undefined || md !== undefined || lg !== undefined, {
    message: "At least one image size must be defined",
});
export const PublicKeySchema = z.string().refine(val => {
    try {
        new PublicKey(val);
        return true;
    }
    catch {
        return false;
    }
}, {
    message: "Invalid public key",
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const KindSchema = z.union(KindOptions.map(k => z.literal(k.toLowerCase())));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export const TagSchema = z.union(TagOptions.map(t => z.literal(t.toLowerCase())));
export const EntrypointPlatformsSchema = z
    .object({
    android: z.string(),
    ios: z.string(),
    web: z.string(),
})
    .strict()
    .partial()
    .refine(({ android, ios, web }) => android !== undefined || ios !== undefined || web !== undefined, {
    message: "At least one platform key must be defined for an entrypoint",
});
export const EntrypointsCustomSchema = z.record(EntrypointPlatformsSchema);
export const EntrypointsDefaultSchema = z.object({
    default: EntrypointPlatformsSchema,
});
export const EntrypointsSchema = EntrypointsDefaultSchema.and(EntrypointsCustomSchema);
export const PropsSchema = z.any();
export const ManifestSchema = z.object({
    entrypoints: EntrypointsSchema,
    icon: ImageSizeOptionsSchema,
    props: PropsSchema.optional(),
    screenshots: ScreenshotsSchema.optional(),
    splash: ImageSizeOptionsSchema.optional(),
});
export const XnftMetadataPropertiesSchema = z.object({
    version: VersionSchema,
    manifest: ManifestSchema,
    programIds: PublicKeySchema.array().optional(),
    history: ManifestHistorySchema,
});
export const AppBuildJsonManifestSchema = z.object({
    description: z.string().min(5),
    entrypoints: EntrypointsSchema,
    icon: ImageSizeOptionsSchema,
    installAuthority: PublicKeySchema.optional(),
    installVault: PublicKeySchema.optional(),
    kind: z.literal("app"),
    name: z.string().min(1).max(32),
    price: z.number().nonnegative().optional(),
    programIds: PublicKeySchema.array().optional(),
    props: z.any().optional(),
    royalitesPercentage: z.number().nonnegative().max(100).optional(),
    screenshots: z.union([ScreenshotsSchema, z.string().array()]).optional(),
    splash: ImageSizeOptionsSchema.optional(),
    supply: z.number().min(1).optional(),
    tag: TagSchema.optional(),
    version: VersionSchema,
    website: z.string().url(),
});
export const CollectibleJsonManifestSchema = z.object({
    collectibleMint: PublicKeySchema,
    entrypoints: EntrypointsSchema,
    kind: z.literal("collectible"),
    programIds: PublicKeySchema.array().optional(),
    props: z.any().optional(),
    screenshots: z.union([ScreenshotsSchema, z.string().array()]).optional(),
    splash: ImageSizeOptionsSchema.optional(),
    version: VersionSchema,
});
export const BuildJsonManifestSchema = z.discriminatedUnion("kind", [
    AppBuildJsonManifestSchema,
    CollectibleJsonManifestSchema,
]);
//# sourceMappingURL=types.js.map