import { PublicKey, Transaction } from '@solana/web3.js';
import { AnchorProvider, parseIdlErrors, Program, BN, translateError } from '@coral-xyz/anchor';
import { Metaplex } from '@metaplex-foundation/js';
import { getAssociatedTokenAddressSync, TOKEN_PROGRAM_ID, ACCOUNT_SIZE, AccountLayout } from '@solana/spl-token';
import semver from 'semver';
import { z } from 'zod';

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
const PROGRAM_ID = new PublicKey("xnft5aaToUM4UFETUQfj7NUDUBdvYHTVhNFThEYTm55");
const TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
/**
 * Derive the PDA for an Access program account.
 * @export
 * @param {PublicKey} wallet
 * @param {PublicKey} xnft
 * @returns {[PublicKey, number]}
 */
function deriveAccessAddress(wallet, xnft) {
    return PublicKey.findProgramAddressSync([Buffer.from("access"), wallet.toBytes(), xnft.toBytes()], PROGRAM_ID);
}
/**
 * Derive the PDA for an Install program account.
 * @export
 * @param {PublicKey} authority
 * @param {PublicKey} xnft
 * @returns {[PublicKey, number]}
 */
function deriveInstallAddress(authority, xnft) {
    return PublicKey.findProgramAddressSync([Buffer.from("install"), authority.toBytes(), xnft.toBytes()], PROGRAM_ID);
}
/**
 * Derive the PDA of the master mint account.
 * @export
 * @param {string} name
 * @param {PublicKey} publisher
 * @returns {[PublicKey, number]}
 */
function deriveMasterMintAddress(name, publisher) {
    return PublicKey.findProgramAddressSync([Buffer.from("mint"), publisher.toBytes(), Buffer.from(name)], PROGRAM_ID);
}
/**
 * Derive the PDA of a Review program account.
 * @export
 * @param {PublicKey} xnft
 * @param {PublicKey} author
 * @returns {[PublicKey, number]}
 */
function deriveReviewAddress(xnft, author) {
    return PublicKey.findProgramAddressSync([Buffer.from("review"), xnft.toBytes(), author.toBytes()], PROGRAM_ID);
}
/**
 * Derive the PDA of the associated xNFT program account.
 * @export
 * @param {PublicKey} masterMint
 * @returns {[PublicKey, number]}
 */
function deriveXnftAddress(masterMint) {
    return PublicKey.findProgramAddressSync([Buffer.from("xnft"), masterMint.toBytes()], PROGRAM_ID);
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * Create a full transaction for `create_app_xnft`.
 * @export
 * @param {...Parameters<typeof createCreateAppXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateAppXnftTransaction(...args) {
    const ix = await createCreateAppXnftInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create the ix instance for the `create_app_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {string} name
 * @param {IdlCreateXnftParameters} params
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateAppXnftInstruction(program, name, params) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const [masterMint] = deriveMasterMintAddress(name, program.provider.publicKey);
    const masterToken = getAssociatedTokenAddressSync(masterMint, program.provider.publicKey);
    return program.methods
        .createAppXnft(name, params)
        .accounts({
        masterMint,
        masterToken,
        metadataProgram: TOKEN_METADATA_PROGRAM_ID,
    })
        .instruction();
}
/**
 * Create a full transaction for `create_collectible_xnft`.
 * @export
 * @param {...Parameters<typeof createCreateCollectibleXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateCollectibleXnftTransaction(...args) {
    const ix = await createCreateCollectibleXnftInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create the ix instance for the `create_collectible_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {IdlCreateXnftParameters} params
 * @param {PublicKey} metadata
 * @param {PublicKey} mint
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateCollectibleXnftInstruction(program, metadata, mint, params) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const masterToken = getAssociatedTokenAddressSync(mint, program.provider.publicKey);
    return program.methods
        .createCollectibleXnft(params)
        .accounts({
        masterMint: mint,
        masterToken,
        masterMetadata: metadata,
    })
        .instruction();
}
/**
 * Create a full transaction for `create_install` or `create_permissioned_install`
 * based on the value of the `permissioned` argument.
 * @export
 * @param {...Parameters<typeof createCreateInstallInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateInstallTransaction(...args) {
    const ix = await createCreateInstallInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create the ix instance for the `create_install` or `create_permissioned_install`
 * instructions based on the value provided in the `permissioned` argument.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} installVault
 * @param {boolean} [permissioned]
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateInstallInstruction(program, xnft, installVault, permissioned) {
    return permissioned
        ? await program.methods.createPermissionedInstall().accounts({ xnft, installVault }).instruction()
        : await program.methods.createInstall().accounts({ xnft, installVault }).instruction();
}
/**
 * Create a full transaction for `create_review`.
 * @export
 * @param {...Parameters<typeof createCreateReviewInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateReviewTransaction(...args) {
    const ix = await createCreateReviewInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `create_review` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {string} uri
 * @param {number} rating
 * @param {PublicKey} install
 * @param {PublicKey} masterToken
 * @param {PublicKey} xnft
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateReviewInstruction(program, uri, rating, install, masterToken, xnft) {
    return program.methods
        .createReview(uri, rating)
        .accounts({
        install,
        masterToken,
        xnft,
    })
        .instruction();
}
/**
 * Create a full transaction for `delete_install`.
 * @export
 * @param {...Parameters<typeof createDeleteInstallInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createDeleteInstallTransaction(...args) {
    const ix = await createDeleteInstallInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `delete_install` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} [receiver]
 * @returns {Promise<TransactionInstruction>}
 */
async function createDeleteInstallInstruction(program, xnft, receiver) {
    const [install] = deriveInstallAddress(program.provider.publicKey, xnft);
    return program.methods
        .deleteInstall()
        .accounts({
        install,
        receiver: receiver !== null && receiver !== void 0 ? receiver : program.provider.publicKey,
    })
        .instruction();
}
/**
 * Create a full transaction for `delete_review`.
 * @export
 * @param {...Parameters<typeof createDeleteReviewInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createDeleteReviewTransaction(...args) {
    const ix = await createDeleteReviewInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `delete_review` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} review
 * @param {PublicKey} [receiver]
 * @returns {Promise<TransactionInstruction>}
 */
async function createDeleteReviewInstruction(program, review, receiver) {
    return program.methods
        .deleteReview()
        .accounts({
        review,
        receiver: receiver !== null && receiver !== void 0 ? receiver : program.provider.publicKey,
    })
        .instruction();
}
/**
 * Create a full transaction for `grant_access`.
 * @export
 * @param {...Parameters<typeof createGrantAccessInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createGrantAccessTransaction(...args) {
    const ix = await createGrantAccessInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `grant_access` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} wallet
 * @returns {Promise<TransactionInstruction>}
 */
async function createGrantAccessInstruction(program, xnft, wallet) {
    return program.methods.grantAccess().accounts({ xnft, wallet }).instruction();
}
/**
 * Create a full transaction for `revoke_access`.
 * @export
 * @param {...Parameters<typeof createRevokeAccessInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createRevokeAccessTransaction(...args) {
    const ix = await createRevokeAccessInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `revoke_access` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} wallet
 * @returns {Promise<TransactionInstruction>}
 */
async function createRevokeAccessInstruction(program, xnft, wallet) {
    return program.methods.revokeAccess().accounts({ xnft, wallet }).instruction();
}
/**
 * Create a full transaction for `set_curator`.
 * @export
 * @param {...Parameters<typeof createSetCuratorInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createSetCuratorTransaction(...args) {
    const ix = await createSetCuratorInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `set_curator` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {PublicKey} curator
 * @returns {Promise<TransactionInstruction>}
 */
async function createSetCuratorInstruction(program, xnft, masterToken, curator) {
    return program.methods
        .setCurator()
        .accounts({
        xnft,
        masterToken,
        curator,
    })
        .instruction();
}
/**
 * Create a full transaction for `set_suspended`.
 * @export
 * @param {...Parameters<typeof createSetSuspendedInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createSetSuspendedTransaction(...args) {
    const ix = await createSetSuspendedInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `set_suspended` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {boolean} value
 * @returns {Promise<TransactionInstruction>}
 */
async function createSetSuspendedInstruction(program, xnft, masterToken, value) {
    return program.methods.setSuspended(value).accounts({ masterToken, xnft }).instruction();
}
/**
 * Create a full transaction for `transfer`.
 * @export
 * @param {...Parameters<typeof createTransferInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createTransferTransaction(...args) {
    const ix = await createTransferInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `transfer` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterMint
 * @param {PublicKey} recipient
 * @returns {Promise<TransactionInstruction>}
 */
async function createTransferInstruction(program, xnft, masterMint, recipient) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const destination = getAssociatedTokenAddressSync(masterMint, recipient);
    const source = getAssociatedTokenAddressSync(masterMint, program.provider.publicKey);
    return program.methods
        .transfer()
        .accounts({
        xnft,
        masterMint,
        source,
        destination,
        recipient,
    })
        .instruction();
}
/**
 * Create a full transaction for `update_xnft`.
 * @export
 * @param {...Parameters<typeof createUpdateXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createUpdateXnftTransaction(...args) {
    const ix = await createUpdateXnftInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `update_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {IdlUpdateXnftParameters} params
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {PublicKey} [curator]
 * @returns {Promise<TransactionInstruction>}
 */
async function createUpdateXnftInstruction(program, params, xnft, masterToken, curator) {
    return program.methods
        .updateXnft(params)
        .accounts({
        masterToken,
        curationAuthority: curator !== null && curator !== void 0 ? curator : program.provider.publicKey,
        xnft,
        metadataProgram: TOKEN_METADATA_PROGRAM_ID,
    })
        .instruction();
}
/**
 * Creates a full transaction for `verify_curator`.
 * @export
 * @param {...Parameters<typeof createVerifyCuratorInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createVerifyCuratorTransaction(...args) {
    const ix = await createVerifyCuratorInstruction(...args);
    return new Transaction().add(ix);
}
/**
 * Create an ix instance for the `verify_curator` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @returns {Promise<TransactionInstruction>}
 */
async function createVerifyCuratorInstruction(program, xnft) {
    return program.methods.verifyCurator().accounts({ xnft }).instruction();
}

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
/**
 * Get the active NFT associated token account for the argued master mint public key
 * that has the token current in the balance.
 * @export
 * @param {Connection} connection
 * @param {PublicKey} mint
 * @returns {Promise<ProgramAccount<TokenAccount>>}
 */
async function getNftTokenAccountForMint(connection, mint) {
    const tokenAccounts = await connection.getProgramAccounts(TOKEN_PROGRAM_ID, {
        filters: [
            { dataSize: ACCOUNT_SIZE },
            {
                memcmp: {
                    offset: 0,
                    bytes: mint.toBase58(),
                },
            },
            {
                memcmp: {
                    offset: 64,
                    bytes: "2", // base-58 encoding of Buffer.from([1]) for a balance of 1
                },
            },
        ],
    });
    if (tokenAccounts.length === 0) {
        throw new Error(`no token accounts found for mint ${mint.toBase58()}`);
    }
    const ata = AccountLayout.decode(tokenAccounts[0].account.data);
    return {
        account: ata,
        publicKey: tokenAccounts[0].pubkey,
    };
}

const IDL = {
    version: "0.2.0",
    name: "xnft",
    constants: [
        {
            name: "MAX_RATING",
            type: "u8",
            value: "5",
        },
    ],
    instructions: [
        {
            name: "createAppXnft",
            docs: [
                "Creates all parts of an xNFT instance.",
                'Once this is invoked, an xNFT exists and can be "installed" by users.',
            ],
            accounts: [
                {
                    name: "masterMint",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "mint",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "publisher",
                            },
                            {
                                kind: "arg",
                                type: "string",
                                path: "name",
                            },
                        ],
                    },
                },
                {
                    name: "masterToken",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "masterMetadata",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "metadata",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "metadata_program",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Mint",
                                path: "master_mint",
                            },
                        ],
                        programId: {
                            kind: "account",
                            type: "publicKey",
                            path: "metadata_program",
                        },
                    },
                },
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "xnft",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Mint",
                                path: "master_mint",
                            },
                        ],
                    },
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "publisher",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "associatedTokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "metadataProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "rent",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "name",
                    type: "string",
                },
                {
                    name: "params",
                    type: {
                        defined: "CreateXnftParams",
                    },
                },
            ],
        },
        {
            name: "createCollectibleXnft",
            docs: ["Creates an xNFT instance on top of an existing digital collectible that is MPL compliant."],
            accounts: [
                {
                    name: "masterMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "masterToken",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "masterMetadata",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "xnft",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Mint",
                                path: "master_mint",
                            },
                        ],
                    },
                },
                {
                    name: "payer",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "publisher",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "params",
                    type: {
                        defined: "CreateXnftParams",
                    },
                },
            ],
        },
        {
            name: "createInstall",
            docs: [
                'Creates an "installation" of an xNFT.',
                "Installation is just a synonym for minting an xNFT edition for a given",
                "user.",
            ],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                    relations: ["install_vault"],
                },
                {
                    name: "installVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "install",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "install",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "target",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                        ],
                    },
                },
                {
                    name: "authority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "target",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "createPermissionedInstall",
            docs: [
                'Creates an "installation" of a private xNFT through prior access approval',
                "granted by the xNFT's installation authority.",
            ],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                    relations: ["install_vault"],
                },
                {
                    name: "installVault",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "install",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "install",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "authority",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                        ],
                    },
                },
                {
                    name: "access",
                    isMut: false,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "access",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "authority",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                        ],
                    },
                    relations: ["xnft"],
                },
                {
                    name: "authority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "createReview",
            docs: ['Creates a "review" of an xNFT containing a URI to a comment and a 0-5 rating.'],
            accounts: [
                {
                    name: "install",
                    isMut: false,
                    isSigner: false,
                    relations: ["xnft"],
                },
                {
                    name: "masterToken",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "review",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "review",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "author",
                            },
                        ],
                    },
                },
                {
                    name: "author",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "uri",
                    type: "string",
                },
                {
                    name: "rating",
                    type: "u8",
                },
            ],
        },
        {
            name: "deleteInstall",
            docs: ["Closes the install account."],
            accounts: [
                {
                    name: "install",
                    isMut: true,
                    isSigner: false,
                    relations: ["authority"],
                },
                {
                    name: "receiver",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "authority",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [],
        },
        {
            name: "deleteReview",
            docs: ["Closes the review account and removes metrics from xNFT account."],
            accounts: [
                {
                    name: "review",
                    isMut: true,
                    isSigner: false,
                    relations: ["author", "xnft"],
                },
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "receiver",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "author",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [],
        },
        {
            name: "grantAccess",
            docs: [
                "Creates an access program account that indicates a wallet's",
                "access permission to install a private xNFT.",
            ],
            accounts: [
                {
                    name: "xnft",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "wallet",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "access",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "access",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "wallet",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                        ],
                    },
                },
                {
                    name: "authority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "revokeAccess",
            docs: [
                "Closes the access program account for a given wallet on a private xNFT,",
                "effectively revoking their permission to create installations of the xNFT.",
            ],
            accounts: [
                {
                    name: "xnft",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "wallet",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "access",
                    isMut: true,
                    isSigner: false,
                    pda: {
                        seeds: [
                            {
                                kind: "const",
                                type: "string",
                                value: "access",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                path: "wallet",
                            },
                            {
                                kind: "account",
                                type: "publicKey",
                                account: "Xnft",
                                path: "xnft",
                            },
                        ],
                    },
                    relations: ["wallet", "xnft"],
                },
                {
                    name: "authority",
                    isMut: true,
                    isSigner: true,
                },
            ],
            args: [],
        },
        {
            name: "setCurator",
            docs: ["Assigns a curator public key to the provided xNFT."],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "masterToken",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "curator",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "authority",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [],
        },
        {
            name: "setSuspended",
            docs: ["Sets the install suspension flag on the xnft."],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "masterToken",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "authority",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [
                {
                    name: "flag",
                    type: "bool",
                },
            ],
        },
        {
            name: "transfer",
            docs: ["Transfer the xNFT to the provided designation wallet."],
            accounts: [
                {
                    name: "xnft",
                    isMut: false,
                    isSigner: false,
                    relations: ["master_mint"],
                },
                {
                    name: "source",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "destination",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "masterMint",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "recipient",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "authority",
                    isMut: true,
                    isSigner: true,
                },
                {
                    name: "systemProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "tokenProgram",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "associatedTokenProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [],
        },
        {
            name: "updateXnft",
            docs: ["Updates the code of an xNFT.", "This is simply a token metadata update cpi."],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                    relations: ["master_metadata"],
                },
                {
                    name: "masterToken",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "masterMetadata",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "curationAuthority",
                    isMut: false,
                    isSigner: false,
                },
                {
                    name: "updater",
                    isMut: false,
                    isSigner: true,
                },
                {
                    name: "metadataProgram",
                    isMut: false,
                    isSigner: false,
                },
            ],
            args: [
                {
                    name: "updates",
                    type: {
                        defined: "UpdateParams",
                    },
                },
            ],
        },
        {
            name: "verifyCurator",
            docs: ["Verifies the assignment of a curator to an xNFT, signed by the curator authority."],
            accounts: [
                {
                    name: "xnft",
                    isMut: true,
                    isSigner: false,
                },
                {
                    name: "curator",
                    isMut: false,
                    isSigner: true,
                },
            ],
            args: [],
        },
    ],
    accounts: [
        {
            name: "access",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "wallet",
                        docs: ["The pubkey of the wallet being granted access (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "xnft",
                        docs: ["The pubkey of the xNFT account that is access gated (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "bump",
                        docs: ["Bump nonce of the PDA (1)."],
                        type: "u8",
                    },
                    {
                        name: "reserved",
                        docs: ["Unused reserved byte space for additive future changes."],
                        type: {
                            array: ["u8", 32],
                        },
                    },
                ],
            },
        },
        {
            name: "install",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "authority",
                        docs: ["The authority who created the installation (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "xnft",
                        docs: ["The pubkey of the xNFT that was installed (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "masterMetadata",
                        docs: ["The pubkey of the MPL master metadata account (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "edition",
                        docs: ["The sequential installation number of the xNFT (8)."],
                        type: "u64",
                    },
                    {
                        name: "reserved",
                        docs: ["Unused reserved byte space for additive future changes."],
                        type: {
                            array: ["u8", 64],
                        },
                    },
                ],
            },
        },
        {
            name: "review",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "author",
                        docs: ["The pubkey of the account that created the review (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "xnft",
                        docs: ["The pubkey of the associated xNFT (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "rating",
                        docs: ["The numerical rating for the review, 0-5 (1)."],
                        type: "u8",
                    },
                    {
                        name: "uri",
                        docs: ["The URI of the off-chain JSON data that holds the comment (4 + len)."],
                        type: "string",
                    },
                    {
                        name: "reserved",
                        docs: ["Unused reserved byte space for future additive changes."],
                        type: {
                            array: ["u8", 32],
                        },
                    },
                ],
            },
        },
        {
            name: "xnft",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "publisher",
                        docs: ["The pubkey of the original xNFT creator (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "installVault",
                        docs: ["The pubkey of the account to receive install payments (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "masterMetadata",
                        docs: ["The pubkey of the MPL master metadata account (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "masterMint",
                        docs: ["The pubkey of the master token mint (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "installAuthority",
                        docs: ["The optional pubkey of the xNFT installation authority (33)."],
                        type: {
                            option: "publicKey",
                        },
                    },
                    {
                        name: "curator",
                        docs: ["Optional pubkey of the global authority required for reviewing xNFT updates (34)."],
                        type: {
                            option: {
                                defined: "CuratorStatus",
                            },
                        },
                    },
                    {
                        name: "uri",
                        docs: ["The URI of the custom metadata blob for the xNFT (4 + mpl_token_metadata::state::MAX_URI_LENGTH)."],
                        type: "string",
                    },
                    {
                        name: "mintSeedName",
                        docs: [
                            "The original name used to seed the master mint if it was a standalone (1 + 4 + mpl_token_metadata::state::MAX_NAME_LENGTH).",
                        ],
                        type: {
                            option: "string",
                        },
                    },
                    {
                        name: "kind",
                        docs: ["The `Kind` enum variant describing the type of xNFT (1)."],
                        type: {
                            defined: "Kind",
                        },
                    },
                    {
                        name: "tag",
                        docs: ["The `Tag` enum variant to assign the category of xNFT (1)."],
                        type: {
                            defined: "Tag",
                        },
                    },
                    {
                        name: "supply",
                        docs: ["The optional finite supply of installations available for this xNFT (9)."],
                        type: {
                            option: "u64",
                        },
                    },
                    {
                        name: "totalInstalls",
                        docs: ["Total amount of install accounts that have been created for this xNFT (8)."],
                        type: "u64",
                    },
                    {
                        name: "installPrice",
                        docs: ["The price-per-install of this xNFT (8)."],
                        type: "u64",
                    },
                    {
                        name: "createdTs",
                        docs: ["The unix timestamp of when the account was created (8)."],
                        type: "i64",
                    },
                    {
                        name: "updatedTs",
                        docs: ["The unix timestamp of the last time the account was updated (8)."],
                        type: "i64",
                    },
                    {
                        name: "totalRating",
                        docs: ["The total cumulative rating value of all reviews (8)."],
                        type: "u64",
                    },
                    {
                        name: "numRatings",
                        docs: ["The number of ratings created used to calculate the average (4)."],
                        type: "u32",
                    },
                    {
                        name: "suspended",
                        docs: ["Flag to determine whether new installations of the xNFT should be halted (1)."],
                        type: "bool",
                    },
                    {
                        name: "bump",
                        docs: ["The bump nonce for the xNFT's PDA (1)."],
                        type: {
                            array: ["u8", 1],
                        },
                    },
                    {
                        name: "reserved0",
                        docs: ["Unused reserved byte space for additive future changes."],
                        type: {
                            array: ["u8", 64],
                        },
                    },
                    {
                        name: "reserved1",
                        type: {
                            array: ["u8", 24],
                        },
                    },
                    {
                        name: "reserved2",
                        type: {
                            array: ["u8", 9],
                        },
                    },
                ],
            },
        },
    ],
    types: [
        {
            name: "CreatorsParam",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "address",
                        type: "publicKey",
                    },
                    {
                        name: "share",
                        type: "u8",
                    },
                ],
            },
        },
        {
            name: "CreateXnftParams",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "creators",
                        type: {
                            vec: {
                                defined: "CreatorsParam",
                            },
                        },
                    },
                    {
                        name: "curator",
                        type: {
                            option: "publicKey",
                        },
                    },
                    {
                        name: "installAuthority",
                        type: {
                            option: "publicKey",
                        },
                    },
                    {
                        name: "installPrice",
                        type: "u64",
                    },
                    {
                        name: "installVault",
                        type: "publicKey",
                    },
                    {
                        name: "sellerFeeBasisPoints",
                        type: "u16",
                    },
                    {
                        name: "supply",
                        type: {
                            option: "u64",
                        },
                    },
                    {
                        name: "symbol",
                        type: "string",
                    },
                    {
                        name: "tag",
                        type: {
                            defined: "Tag",
                        },
                    },
                    {
                        name: "uri",
                        type: "string",
                    },
                ],
            },
        },
        {
            name: "UpdateParams",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "installAuthority",
                        type: {
                            option: "publicKey",
                        },
                    },
                    {
                        name: "installPrice",
                        type: "u64",
                    },
                    {
                        name: "installVault",
                        type: "publicKey",
                    },
                    {
                        name: "name",
                        type: {
                            option: "string",
                        },
                    },
                    {
                        name: "supply",
                        type: {
                            option: "u64",
                        },
                    },
                    {
                        name: "tag",
                        type: {
                            defined: "Tag",
                        },
                    },
                    {
                        name: "uri",
                        type: {
                            option: "string",
                        },
                    },
                ],
            },
        },
        {
            name: "CuratorStatus",
            type: {
                kind: "struct",
                fields: [
                    {
                        name: "pubkey",
                        docs: ["The pubkey of the `Curator` program account (32)."],
                        type: "publicKey",
                    },
                    {
                        name: "verified",
                        docs: ["Whether the curator's authority has verified the assignment (1)."],
                        type: "bool",
                    },
                ],
            },
        },
        {
            name: "Kind",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "App",
                    },
                    {
                        name: "Collectible",
                    },
                ],
            },
        },
        {
            name: "Tag",
            type: {
                kind: "enum",
                variants: [
                    {
                        name: "None",
                    },
                    {
                        name: "Defi",
                    },
                    {
                        name: "Game",
                    },
                    {
                        name: "Nfts",
                    },
                ],
            },
        },
    ],
    events: [
        {
            name: "AccessGranted",
            fields: [
                {
                    name: "wallet",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "xnft",
                    type: "publicKey",
                    index: false,
                },
            ],
        },
        {
            name: "InstallationCreated",
            fields: [
                {
                    name: "installer",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "xnft",
                    type: "publicKey",
                    index: false,
                },
            ],
        },
        {
            name: "ReviewCreated",
            fields: [
                {
                    name: "author",
                    type: "publicKey",
                    index: false,
                },
                {
                    name: "rating",
                    type: "u8",
                    index: false,
                },
                {
                    name: "xnft",
                    type: "publicKey",
                    index: false,
                },
            ],
        },
        {
            name: "XnftCreated",
            fields: [
                {
                    name: "tag",
                    type: {
                        defined: "Tag",
                    },
                    index: false,
                },
                {
                    name: "xnft",
                    type: "publicKey",
                    index: false,
                },
            ],
        },
        {
            name: "XnftUpdated",
            fields: [
                {
                    name: "xnft",
                    type: "publicKey",
                    index: false,
                },
            ],
        },
    ],
    errors: [
        {
            code: 6000,
            name: "CannotReviewOwned",
            msg: "You cannot create a review for an xNFT that you currently own or published",
        },
        {
            code: 6001,
            name: "CuratorAlreadySet",
            msg: "There is already a verified curator assigned",
        },
        {
            code: 6002,
            name: "CuratorAuthorityMismatch",
            msg: "The expected curator authority did not match expected",
        },
        {
            code: 6003,
            name: "CuratorMismatch",
            msg: "The provided curator account did not match the one assigned",
        },
        {
            code: 6004,
            name: "InstallAuthorityMismatch",
            msg: "The provided xNFT install authority did not match",
        },
        {
            code: 6005,
            name: "InstallExceedsSupply",
            msg: "The max supply has been reached for the xNFT",
        },
        {
            code: 6006,
            name: "InstallOwnerMismatch",
            msg: "The asserted authority/owner did not match that of the Install account",
        },
        {
            code: 6007,
            name: "MetadataIsImmutable",
            msg: "The metadata of the xNFT is marked as immutable",
        },
        {
            code: 6008,
            name: "MustBeApp",
            msg: "The xNFT must be of `Kind::App` for this operation",
        },
        {
            code: 6009,
            name: "RatingOutOfBounds",
            msg: "The rating for a review must be between 0 and 5",
        },
        {
            code: 6010,
            name: "ReviewInstallMismatch",
            msg: "The installation provided for the review does not match the xNFT",
        },
        {
            code: 6011,
            name: "SupplyReduction",
            msg: "Updated supply is less than the original supply set on creation",
        },
        {
            code: 6012,
            name: "SuspendedInstallation",
            msg: "Attempting to install a currently suspended xNFT",
        },
        {
            code: 6013,
            name: "UnauthorizedInstall",
            msg: "The access account provided is not associated with the wallet",
        },
        {
            code: 6014,
            name: "UpdateAuthorityMismatch",
            msg: "The signer did not match the update authority of the metadata account or the owner",
        },
        {
            code: 6015,
            name: "UpdateReviewAuthorityMismatch",
            msg: "The signing authority for the xNFT update did not match the review authority",
        },
        {
            code: 6016,
            name: "UriExceedsMaxLength",
            msg: "The metadata URI provided exceeds the maximum length",
        },
    ],
};

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
function buildAnonymousProvider(connection) {
    return new AnchorProvider(connection, 
    /* eslint @typescript-eslint/ban-ts-comment: 0 */
    // @ts-ignore
    { publicKey: PublicKey.default }, {});
}
function enumsEqual(variant, other) {
    return Object.keys(variant)[0] === other;
}
function gatewayUri(uri) {
    return uri.replace("ipfs://", "https://nftstorage.link/ipfs/");
}

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
var _xNFT_mpl, _xNFT_program, _xNFT_provider;
const idlErrors = parseIdlErrors(IDL);
class xNFT {
    /**
     * Creates an instance of xNFT.
     * @param {Provider} provider
     * @memberof xNFT
     */
    constructor(provider) {
        _xNFT_mpl.set(this, void 0);
        _xNFT_program.set(this, void 0);
        _xNFT_provider.set(this, void 0);
        if (!provider.publicKey) {
            throw new Error("no public key found on the argued provider");
        }
        else if (!provider.sendAndConfirm) {
            throw new Error("no sendAndConfirm function found on the argued provider");
        }
        __classPrivateFieldSet(this, _xNFT_mpl, Metaplex.make(provider.connection), "f");
        __classPrivateFieldSet(this, _xNFT_program, new Program(IDL, PROGRAM_ID, provider), "f");
        __classPrivateFieldSet(this, _xNFT_provider, provider, "f");
    }
    /**
     * Create an instance of the client without a full provider.
     * @static
     * @param {Connection} connection
     * @returns {xNFT}
     * @memberof xNFT
     */
    static anonymous(connection) {
        return new xNFT(buildAnonymousProvider(connection));
    }
    /**
     * Readonly accessor for the internal Metaplex SDK instance.
     * @readonly
     * @type {Metaplex}
     * @memberof xNFT
     */
    get metaplex() {
        return __classPrivateFieldGet(this, _xNFT_mpl, "f");
    }
    /**
     * Readonly access for the internal program instance.
     * @readonly
     * @type {Program<Xnft>}
     * @memberof xNFT
     */
    get program() {
        return __classPrivateFieldGet(this, _xNFT_program, "f");
    }
    /**
     * Readonly accessor for the internal provider instance.
     * @readonly
     * @type {Provider}
     * @memberof xNFT
     */
    get provider() {
        return __classPrivateFieldGet(this, _xNFT_provider, "f");
    }
    /**
     * Create a standalone application xNFT.
     * @param {CreateXnftAppOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async createAppXnft(opts) {
        var _a, _b, _c, _d, _e, _f;
        const tx = await createCreateAppXnftTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), opts.name, {
            creators: opts.creators,
            curator: (_a = opts.curator) !== null && _a !== void 0 ? _a : null,
            installAuthority: (_b = opts.installAuthority) !== null && _b !== void 0 ? _b : null,
            installPrice: (_c = opts.installPrice) !== null && _c !== void 0 ? _c : new BN(0),
            installVault: (_d = opts.installVault) !== null && _d !== void 0 ? _d : __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey,
            sellerFeeBasisPoints: (_e = opts.sellerFeeBasisPoints) !== null && _e !== void 0 ? _e : 0,
            supply: (_f = opts.supply) !== null && _f !== void 0 ? _f : null,
            symbol: "",
            tag: { [opts.tag]: {} },
            uri: opts.uri,
        });
        return this._withParsedTransactionError(tx);
    }
    /**
     * Create a digital collectible associated xNFT.
     * @param {CreateXnftCollectibleOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async createCollectibleXnft(opts) {
        const tx = await createCreateCollectibleXnftTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), opts.metadata, opts.mint, {
            creators: [],
            curator: null,
            installAuthority: null,
            installPrice: new BN(0),
            installVault: __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey,
            sellerFeeBasisPoints: 0,
            supply: null,
            symbol: "",
            tag: { [opts.tag]: {} },
            uri: opts.uri,
        });
        return this._withParsedTransactionError(tx);
    }
    /**
     * Delete a review for an xNFT that the provider wallet had created.
     * @param {PublicKey} review
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async deleteReview(review, receiver) {
        const tx = await createDeleteReviewTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), review, receiver);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Get the data for the argued xNFT public key and its peripheral accounts.
     * @param {PublicKey} publicKey
     * @returns {Promise<XnftAccount>}
     * @memberof xNFT
     */
    async getAccount(publicKey) {
        const account = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.fetch(publicKey));
        const [tokenAccount, xnftBlob, metadatas] = await Promise.all([
            getNftTokenAccountForMint(__classPrivateFieldGet(this, _xNFT_provider, "f").connection, account.masterMint),
            __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(account.uri)),
            __classPrivateFieldGet(this, _xNFT_mpl, "f").nfts().findAllByMintList({ mints: [account.masterMint] }),
        ]);
        const md = metadatas[0];
        let mplBlob = {};
        if (!enumsEqual(account.kind, "app")) {
            mplBlob = await __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(md.uri));
        }
        return {
            data: account,
            metadata: {
                ...md,
                json: {
                    ...xnftBlob,
                    ...mplBlob,
                },
            },
            publicKey,
            token: {
                address: tokenAccount.publicKey,
                owner: tokenAccount.account.owner,
            },
        };
    }
    /**
     * Gets all of the xNFT accounts and their data for the argued owner public key.
     * @param {PublicKey} owner
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    async getAccountsByOwner(owner) {
        const metadatas = (await __classPrivateFieldGet(this, _xNFT_mpl, "f").nfts().findAllByOwner({ owner }));
        // Early empty return if no metadata accounts were found for the owner
        if (metadatas.length === 0) {
            return [];
        }
        const possibleXnftPdas = metadatas.map(m => deriveXnftAddress(m.mintAddress));
        const possibleXnftAddresses = possibleXnftPdas.map(a => a[0]);
        const results = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.fetchMultiple(possibleXnftAddresses));
        // Early empty return if all possible xNFT addresses fetched were null
        if (results.every(r => !r)) {
            return [];
        }
        const validXnfts = results.reduce((acc, curr, idx) => {
            if (curr) {
                return [...acc, { account: curr, metadata: metadatas[idx], publicKey: possibleXnftAddresses[idx] }];
            }
            return acc;
        }, []);
        const xnftBlobs = await Promise.all(validXnfts.map(x => __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(x.account.uri))));
        const mplBlobs = await Promise.all(validXnfts.map(x => enumsEqual(x.account.kind, "app")
            ? Promise.resolve({})
            : __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(x.metadata.uri))));
        const tokenAccounts = validXnfts.map(x => getAssociatedTokenAddressSync(x.account.masterMint, owner));
        const owned = [];
        validXnfts.forEach((x, idx) => {
            owned.push({
                data: x.account,
                metadata: {
                    ...x.metadata,
                    json: {
                        ...xnftBlobs[idx],
                        ...mplBlobs[idx],
                    },
                },
                publicKey: x.publicKey,
                token: {
                    address: tokenAccounts[idx],
                    owner,
                },
            });
        });
        return owned;
    }
    /**
     * Get the installed xNFTs for the argued wallet public key.
     * @param {PublicKey} wallet
     * @returns {Promise<{ install: IdlInstallAccount; xnft: XnftAccount }[]>}
     * @memberof xNFT
     */
    async getInstallations(wallet) {
        const installations = await __classPrivateFieldGet(this, _xNFT_program, "f").account.install.all([
            {
                memcmp: {
                    offset: 8,
                    bytes: wallet.toBase58(),
                },
            },
        ]);
        const items = [];
        for await (const i of installations) {
            const xnft = await this.getAccount(i.account.xnft);
            items.push({
                install: i.account,
                xnft,
            });
        }
        return items;
    }
    /**
     * Get multiple xNFT program accounts and peripheral data based on the optionally
     * provided program account filters.
     * @param {Kind | null} [kind]
     * @param {GetProgramAccountsFilter[]} [filters]
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    async getMultipleAccounts(kind, filters) {
        const xnfts = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.all(filters));
        const filteredXnfts = kind ? xnfts.filter(x => enumsEqual(x.account.kind, kind)) : xnfts;
        const metadatas = (await __classPrivateFieldGet(this, _xNFT_mpl, "f")
            .nfts()
            .findAllByMintList({ mints: filteredXnfts.map(x => x.account.masterMint) }));
        const xnftBlobs = await Promise.all(filteredXnfts.map(x => __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(x.account.uri))));
        const mplBlobs = await Promise.all(filteredXnfts.map((acc, idx) => enumsEqual(acc.account.kind, "app")
            ? Promise.resolve({})
            : __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson(gatewayUri(metadatas[idx].uri))));
        const tokenAccounts = await Promise.all(metadatas.map(m => getNftTokenAccountForMint(__classPrivateFieldGet(this, _xNFT_provider, "f").connection, m.mintAddress)));
        const response = [];
        filteredXnfts.forEach((acc, idx) => {
            response.push({
                data: acc.account,
                metadata: {
                    ...metadatas[idx],
                    json: {
                        ...xnftBlobs[idx],
                        ...mplBlobs[idx],
                    },
                },
                publicKey: acc.publicKey,
                token: {
                    address: tokenAccounts[idx].publicKey,
                    owner: tokenAccounts[idx].account.owner,
                },
            });
        });
        return response;
    }
    /**
     * Get all Review program accounts associated with the argued xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<ProgramAccount<IdlReviewAccount>[]>}
     * @memberof xNFT
     */
    async getReviews(xnft) {
        return __classPrivateFieldGet(this, _xNFT_program, "f").account.review.all([
            {
                memcmp: {
                    offset: 40,
                    bytes: xnft.toBase58(),
                },
            },
        ]);
    }
    /**
     * Grant access to the argued wallet for the xNFT that should be private
     * and being signed by the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async grantAccess(xnft, wallet) {
        const tx = await createGrantAccessTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, wallet);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Install an xNFT for the wallet on the provider.
     * @param {PublicKey} xnft
     * @param {PublicKey} installVault
     * @param {boolean} [permissioned]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async install(xnft, installVault, permissioned) {
        const tx = await createCreateInstallTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, installVault, permissioned);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows a wallet with an active installation of the argued xNFT
     * publish their review content to a program account and leave a
     * 0-5 rating.
     * @param {string} uri
     * @param {number} rating
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async review(uri, rating, xnft, masterToken) {
        const [install] = deriveInstallAddress(__classPrivateFieldGet(this, _xNFT_provider, "f").publicKey, xnft);
        const tx = await createCreateReviewTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), uri, rating, install, masterToken, xnft);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Remove access from the private xNFT for the argued wallet. Signer of the
     * transaction must be the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async revokeAccess(xnft, wallet) {
        const tx = await createRevokeAccessTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, wallet);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows the authority of an xNFT to begin the curation assignment process.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @param {PublicKey} curator
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async setCurator(xnft, masterToken, curator) {
        const tx = await createSetCuratorTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterToken, curator);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Toggles the suspended field of the xNFT to the argued flag value.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {boolean} value
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async setSuspended(xnft, masterMint, value) {
        const masterToken = getAssociatedTokenAddressSync(masterMint, __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey);
        const tx = await createSetSuspendedTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterToken, value);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Transfers ownership and authority of the xNFT to the argued recipient.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {PublicKey} recipient
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async transfer(xnft, masterMint, recipient) {
        const tx = await createTransferTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterMint, recipient);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Attempts to update the xNFT's metadata with option signing requirements
     * from a curation entity. All values provided to the options parameter are
     * binding and should be populated with the previous values to be unchanged.
     * @param {PublicKey} masterMint
     * @param {UpdateXnftOptions} opts
     * @param {PublicKey} [curator]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async update(masterMint, opts, curator) {
        var _a, _b, _c, _d;
        const [xnft] = deriveXnftAddress(masterMint);
        const masterToken = getAssociatedTokenAddressSync(masterMint, __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey);
        const tx = await createUpdateXnftTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), {
            installAuthority: (_a = opts.installAuthority) !== null && _a !== void 0 ? _a : null,
            installPrice: opts.installPrice,
            installVault: opts.installVault,
            name: (_b = opts.name) !== null && _b !== void 0 ? _b : null,
            supply: (_c = opts.supply) !== null && _c !== void 0 ? _c : null,
            tag: { [opts.tag]: {} },
            uri: (_d = opts.uri) !== null && _d !== void 0 ? _d : null,
        }, xnft, masterToken, curator);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Delete and remove an installed xNFT from the provider wallet and return
     * the rent lamports to the wallet, or to the argued receiver public key
     * if one is provided.
     * @param {PublicKey} xnft
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async uninstall(xnft, receiver) {
        const tx = await createDeleteInstallTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, receiver);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows a curation authority to verify their assignment on an xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async verify(xnft) {
        const tx = await createVerifyCuratorTransaction(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Utility function to wrap a transaction execution and parse
     * the resulting logs for any errors.
     * @private
     * @param {Transaction} tx
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async _withParsedTransactionError(tx) {
        try {
            return await __classPrivateFieldGet(this, _xNFT_provider, "f").sendAndConfirm(tx);
        }
        catch (err) {
            throw translateError(err, idlErrors);
        }
    }
}
_xNFT_mpl = new WeakMap(), _xNFT_program = new WeakMap(), _xNFT_provider = new WeakMap();

/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
// =================
// ABSTRACTION TYPES
// =================
const KindOptions = IDL.types[4].type.variants.map(v => v.name);
console.assert(IDL.types[4].type.variants.map(v => v.name).includes("App"));
const TagOptions = IDL.types[5].type.variants.map(v => v.name);
console.assert(IDL.types[5].type.variants.map(v => v.name).includes("Defi"));
// =========================
// MANIFEST SCHEMA AND TYPES
// =========================
const VersionSchema = z
    .custom()
    .refine(val => semver.valid(val) !== null, {
    message: "Invalid semantic version",
    path: ["version"],
});
const ManifestHistorySchema = z.object({ version: VersionSchema, uri: z.string() }).array();
const ScreenshotsSchema = z
    .object({
    uri: z.string(),
    type: z.string(),
})
    .array();
const ImageSizeOptionsSchema = z
    .object({
    sm: z.string(),
    md: z.string(),
    lg: z.string(),
})
    .strict()
    .partial()
    .refine(({ sm, md, lg }) => sm !== undefined || md !== undefined || lg !== undefined, {
    message: "At least one image size must be defined",
});
const PublicKeySchema = z.string().refine(val => {
    try {
        new PublicKey(val);
        return true;
    }
    catch {
        return false;
    }
}, {
    message: "Invalid public key",
});
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const KindSchema = z.union(KindOptions.map(k => z.literal(k.toLowerCase())));
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const TagSchema = z.union(TagOptions.map(t => z.literal(t.toLowerCase())));
const EntrypointPlatformsSchema = z
    .object({
    android: z.string(),
    ios: z.string(),
    web: z.string(),
})
    .strict()
    .partial()
    .refine(({ android, ios, web }) => android !== undefined || ios !== undefined || web !== undefined, {
    message: "At least one platform key must be defined for an entrypoint",
});
const EntrypointsCustomSchema = z.record(EntrypointPlatformsSchema);
const EntrypointsDefaultSchema = z.object({
    default: EntrypointPlatformsSchema,
});
const EntrypointsSchema = EntrypointsDefaultSchema.and(EntrypointsCustomSchema);
const PropsSchema = z.any();
const ManifestSchema = z.object({
    entrypoints: EntrypointsSchema,
    icon: ImageSizeOptionsSchema,
    props: PropsSchema.optional(),
    screenshots: ScreenshotsSchema.optional(),
    splash: ImageSizeOptionsSchema.optional(),
});
const XnftMetadataPropertiesSchema = z.object({
    version: VersionSchema,
    manifest: ManifestSchema,
    programIds: PublicKeySchema.array().optional(),
    history: ManifestHistorySchema,
});
const AppBuildJsonManifestSchema = z.object({
    description: z.string().min(5),
    entrypoints: EntrypointsSchema,
    icon: ImageSizeOptionsSchema,
    installAuthority: PublicKeySchema.optional(),
    installVault: PublicKeySchema.optional(),
    kind: z.literal("app"),
    name: z.string().min(1).max(32),
    price: z.number().nonnegative().optional(),
    programIds: PublicKeySchema.array().optional(),
    props: z.any().optional(),
    royalitesPercentage: z.number().nonnegative().max(100).optional(),
    screenshots: z.union([ScreenshotsSchema, z.string().array()]).optional(),
    splash: ImageSizeOptionsSchema.optional(),
    supply: z.number().min(1).optional(),
    tag: TagSchema.optional(),
    version: VersionSchema,
    website: z.string().url(),
});
const CollectibleJsonManifestSchema = z.object({
    collectibleMint: PublicKeySchema,
    entrypoints: EntrypointsSchema,
    kind: z.literal("collectible"),
    programIds: PublicKeySchema.array().optional(),
    props: z.any().optional(),
    screenshots: z.union([ScreenshotsSchema, z.string().array()]).optional(),
    splash: ImageSizeOptionsSchema.optional(),
    version: VersionSchema,
});
const BuildJsonManifestSchema = z.discriminatedUnion("kind", [
    AppBuildJsonManifestSchema,
    CollectibleJsonManifestSchema,
]);

export { AppBuildJsonManifestSchema, BuildJsonManifestSchema, CollectibleJsonManifestSchema, EntrypointPlatformsSchema, EntrypointsCustomSchema, EntrypointsDefaultSchema, EntrypointsSchema, IDL, ImageSizeOptionsSchema, KindOptions, KindSchema, ManifestHistorySchema, ManifestSchema, PROGRAM_ID, PropsSchema, PublicKeySchema, ScreenshotsSchema, TOKEN_METADATA_PROGRAM_ID, TagOptions, TagSchema, VersionSchema, XnftMetadataPropertiesSchema, createCreateAppXnftInstruction, createCreateAppXnftTransaction, createCreateCollectibleXnftInstruction, createCreateCollectibleXnftTransaction, createCreateInstallInstruction, createCreateInstallTransaction, createCreateReviewInstruction, createCreateReviewTransaction, createDeleteInstallInstruction, createDeleteInstallTransaction, createDeleteReviewInstruction, createDeleteReviewTransaction, createGrantAccessInstruction, createGrantAccessTransaction, createRevokeAccessInstruction, createRevokeAccessTransaction, createSetCuratorInstruction, createSetCuratorTransaction, createSetSuspendedInstruction, createSetSuspendedTransaction, createTransferInstruction, createTransferTransaction, createUpdateXnftInstruction, createUpdateXnftTransaction, createVerifyCuratorInstruction, createVerifyCuratorTransaction, deriveAccessAddress, deriveInstallAddress, deriveMasterMintAddress, deriveReviewAddress, deriveXnftAddress, xNFT };
//# sourceMappingURL=index.mjs.map
