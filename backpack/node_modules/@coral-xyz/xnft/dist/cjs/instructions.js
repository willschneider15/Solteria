"use strict";
/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVerifyCuratorInstruction = exports.createVerifyCuratorTransaction = exports.createUpdateXnftInstruction = exports.createUpdateXnftTransaction = exports.createTransferInstruction = exports.createTransferTransaction = exports.createSetSuspendedInstruction = exports.createSetSuspendedTransaction = exports.createSetCuratorInstruction = exports.createSetCuratorTransaction = exports.createRevokeAccessInstruction = exports.createRevokeAccessTransaction = exports.createGrantAccessInstruction = exports.createGrantAccessTransaction = exports.createDeleteReviewInstruction = exports.createDeleteReviewTransaction = exports.createDeleteInstallInstruction = exports.createDeleteInstallTransaction = exports.createCreateReviewInstruction = exports.createCreateReviewTransaction = exports.createCreateInstallInstruction = exports.createCreateInstallTransaction = exports.createCreateCollectibleXnftInstruction = exports.createCreateCollectibleXnftTransaction = exports.createCreateAppXnftInstruction = exports.createCreateAppXnftTransaction = void 0;
const spl_token_1 = require("@solana/spl-token");
const web3_js_1 = require("@solana/web3.js");
const addresses_1 = require("./addresses");
/**
 * Create a full transaction for `create_app_xnft`.
 * @export
 * @param {...Parameters<typeof createCreateAppXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateAppXnftTransaction(...args) {
    const ix = await createCreateAppXnftInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createCreateAppXnftTransaction = createCreateAppXnftTransaction;
/**
 * Create the ix instance for the `create_app_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {string} name
 * @param {IdlCreateXnftParameters} params
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateAppXnftInstruction(program, name, params) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const [masterMint] = (0, addresses_1.deriveMasterMintAddress)(name, program.provider.publicKey);
    const masterToken = (0, spl_token_1.getAssociatedTokenAddressSync)(masterMint, program.provider.publicKey);
    return program.methods
        .createAppXnft(name, params)
        .accounts({
        masterMint,
        masterToken,
        metadataProgram: addresses_1.TOKEN_METADATA_PROGRAM_ID,
    })
        .instruction();
}
exports.createCreateAppXnftInstruction = createCreateAppXnftInstruction;
/**
 * Create a full transaction for `create_collectible_xnft`.
 * @export
 * @param {...Parameters<typeof createCreateCollectibleXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateCollectibleXnftTransaction(...args) {
    const ix = await createCreateCollectibleXnftInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createCreateCollectibleXnftTransaction = createCreateCollectibleXnftTransaction;
/**
 * Create the ix instance for the `create_collectible_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {IdlCreateXnftParameters} params
 * @param {PublicKey} metadata
 * @param {PublicKey} mint
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateCollectibleXnftInstruction(program, metadata, mint, params) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const masterToken = (0, spl_token_1.getAssociatedTokenAddressSync)(mint, program.provider.publicKey);
    return program.methods
        .createCollectibleXnft(params)
        .accounts({
        masterMint: mint,
        masterToken,
        masterMetadata: metadata,
    })
        .instruction();
}
exports.createCreateCollectibleXnftInstruction = createCreateCollectibleXnftInstruction;
/**
 * Create a full transaction for `create_install` or `create_permissioned_install`
 * based on the value of the `permissioned` argument.
 * @export
 * @param {...Parameters<typeof createCreateInstallInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateInstallTransaction(...args) {
    const ix = await createCreateInstallInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createCreateInstallTransaction = createCreateInstallTransaction;
/**
 * Create the ix instance for the `create_install` or `create_permissioned_install`
 * instructions based on the value provided in the `permissioned` argument.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} installVault
 * @param {boolean} [permissioned]
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateInstallInstruction(program, xnft, installVault, permissioned) {
    return permissioned
        ? await program.methods.createPermissionedInstall().accounts({ xnft, installVault }).instruction()
        : await program.methods.createInstall().accounts({ xnft, installVault }).instruction();
}
exports.createCreateInstallInstruction = createCreateInstallInstruction;
/**
 * Create a full transaction for `create_review`.
 * @export
 * @param {...Parameters<typeof createCreateReviewInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createCreateReviewTransaction(...args) {
    const ix = await createCreateReviewInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createCreateReviewTransaction = createCreateReviewTransaction;
/**
 * Create an ix instance for the `create_review` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {string} uri
 * @param {number} rating
 * @param {PublicKey} install
 * @param {PublicKey} masterToken
 * @param {PublicKey} xnft
 * @returns {Promise<TransactionInstruction>}
 */
async function createCreateReviewInstruction(program, uri, rating, install, masterToken, xnft) {
    return program.methods
        .createReview(uri, rating)
        .accounts({
        install,
        masterToken,
        xnft,
    })
        .instruction();
}
exports.createCreateReviewInstruction = createCreateReviewInstruction;
/**
 * Create a full transaction for `delete_install`.
 * @export
 * @param {...Parameters<typeof createDeleteInstallInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createDeleteInstallTransaction(...args) {
    const ix = await createDeleteInstallInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createDeleteInstallTransaction = createDeleteInstallTransaction;
/**
 * Create an ix instance for the `delete_install` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} [receiver]
 * @returns {Promise<TransactionInstruction>}
 */
async function createDeleteInstallInstruction(program, xnft, receiver) {
    const [install] = (0, addresses_1.deriveInstallAddress)(program.provider.publicKey, xnft);
    return program.methods
        .deleteInstall()
        .accounts({
        install,
        receiver: receiver !== null && receiver !== void 0 ? receiver : program.provider.publicKey,
    })
        .instruction();
}
exports.createDeleteInstallInstruction = createDeleteInstallInstruction;
/**
 * Create a full transaction for `delete_review`.
 * @export
 * @param {...Parameters<typeof createDeleteReviewInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createDeleteReviewTransaction(...args) {
    const ix = await createDeleteReviewInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createDeleteReviewTransaction = createDeleteReviewTransaction;
/**
 * Create an ix instance for the `delete_review` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} review
 * @param {PublicKey} [receiver]
 * @returns {Promise<TransactionInstruction>}
 */
async function createDeleteReviewInstruction(program, review, receiver) {
    return program.methods
        .deleteReview()
        .accounts({
        review,
        receiver: receiver !== null && receiver !== void 0 ? receiver : program.provider.publicKey,
    })
        .instruction();
}
exports.createDeleteReviewInstruction = createDeleteReviewInstruction;
/**
 * Create a full transaction for `grant_access`.
 * @export
 * @param {...Parameters<typeof createGrantAccessInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createGrantAccessTransaction(...args) {
    const ix = await createGrantAccessInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createGrantAccessTransaction = createGrantAccessTransaction;
/**
 * Create an ix instance for the `grant_access` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} wallet
 * @returns {Promise<TransactionInstruction>}
 */
async function createGrantAccessInstruction(program, xnft, wallet) {
    return program.methods.grantAccess().accounts({ xnft, wallet }).instruction();
}
exports.createGrantAccessInstruction = createGrantAccessInstruction;
/**
 * Create a full transaction for `revoke_access`.
 * @export
 * @param {...Parameters<typeof createRevokeAccessInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createRevokeAccessTransaction(...args) {
    const ix = await createRevokeAccessInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createRevokeAccessTransaction = createRevokeAccessTransaction;
/**
 * Create an ix instance for the `revoke_access` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} wallet
 * @returns {Promise<TransactionInstruction>}
 */
async function createRevokeAccessInstruction(program, xnft, wallet) {
    return program.methods.revokeAccess().accounts({ xnft, wallet }).instruction();
}
exports.createRevokeAccessInstruction = createRevokeAccessInstruction;
/**
 * Create a full transaction for `set_curator`.
 * @export
 * @param {...Parameters<typeof createSetCuratorInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createSetCuratorTransaction(...args) {
    const ix = await createSetCuratorInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createSetCuratorTransaction = createSetCuratorTransaction;
/**
 * Create an ix instance for the `set_curator` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {PublicKey} curator
 * @returns {Promise<TransactionInstruction>}
 */
async function createSetCuratorInstruction(program, xnft, masterToken, curator) {
    return program.methods
        .setCurator()
        .accounts({
        xnft,
        masterToken,
        curator,
    })
        .instruction();
}
exports.createSetCuratorInstruction = createSetCuratorInstruction;
/**
 * Create a full transaction for `set_suspended`.
 * @export
 * @param {...Parameters<typeof createSetSuspendedInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createSetSuspendedTransaction(...args) {
    const ix = await createSetSuspendedInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createSetSuspendedTransaction = createSetSuspendedTransaction;
/**
 * Create an ix instance for the `set_suspended` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {boolean} value
 * @returns {Promise<TransactionInstruction>}
 */
async function createSetSuspendedInstruction(program, xnft, masterToken, value) {
    return program.methods.setSuspended(value).accounts({ masterToken, xnft }).instruction();
}
exports.createSetSuspendedInstruction = createSetSuspendedInstruction;
/**
 * Create a full transaction for `transfer`.
 * @export
 * @param {...Parameters<typeof createTransferInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createTransferTransaction(...args) {
    const ix = await createTransferInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createTransferTransaction = createTransferTransaction;
/**
 * Create an ix instance for the `transfer` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @param {PublicKey} masterMint
 * @param {PublicKey} recipient
 * @returns {Promise<TransactionInstruction>}
 */
async function createTransferInstruction(program, xnft, masterMint, recipient) {
    if (!program.provider.publicKey) {
        throw new Error("no public key found on the program provider");
    }
    const destination = (0, spl_token_1.getAssociatedTokenAddressSync)(masterMint, recipient);
    const source = (0, spl_token_1.getAssociatedTokenAddressSync)(masterMint, program.provider.publicKey);
    return program.methods
        .transfer()
        .accounts({
        xnft,
        masterMint,
        source,
        destination,
        recipient,
    })
        .instruction();
}
exports.createTransferInstruction = createTransferInstruction;
/**
 * Create a full transaction for `update_xnft`.
 * @export
 * @param {...Parameters<typeof createUpdateXnftInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createUpdateXnftTransaction(...args) {
    const ix = await createUpdateXnftInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createUpdateXnftTransaction = createUpdateXnftTransaction;
/**
 * Create an ix instance for the `update_xnft` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {IdlUpdateXnftParameters} params
 * @param {PublicKey} xnft
 * @param {PublicKey} masterToken
 * @param {PublicKey} [curator]
 * @returns {Promise<TransactionInstruction>}
 */
async function createUpdateXnftInstruction(program, params, xnft, masterToken, curator) {
    return program.methods
        .updateXnft(params)
        .accounts({
        masterToken,
        curationAuthority: curator !== null && curator !== void 0 ? curator : program.provider.publicKey,
        xnft,
        metadataProgram: addresses_1.TOKEN_METADATA_PROGRAM_ID,
    })
        .instruction();
}
exports.createUpdateXnftInstruction = createUpdateXnftInstruction;
/**
 * Creates a full transaction for `verify_curator`.
 * @export
 * @param {...Parameters<typeof createVerifyCuratorInstruction>} args
 * @returns {Promise<Transaction>}
 */
async function createVerifyCuratorTransaction(...args) {
    const ix = await createVerifyCuratorInstruction(...args);
    return new web3_js_1.Transaction().add(ix);
}
exports.createVerifyCuratorTransaction = createVerifyCuratorTransaction;
/**
 * Create an ix instance for the `verify_curator` instruction.
 * @export
 * @param {Program<Xnft>} program
 * @param {PublicKey} xnft
 * @returns {Promise<TransactionInstruction>}
 */
async function createVerifyCuratorInstruction(program, xnft) {
    return program.methods.verifyCurator().accounts({ xnft }).instruction();
}
exports.createVerifyCuratorInstruction = createVerifyCuratorInstruction;
//# sourceMappingURL=instructions.js.map