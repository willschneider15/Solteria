"use strict";
/*
 * Copyright (C) 2023 Blue Coral, Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _xNFT_mpl, _xNFT_program, _xNFT_provider;
Object.defineProperty(exports, "__esModule", { value: true });
exports.xNFT = void 0;
const anchor_1 = require("@coral-xyz/anchor");
const js_1 = require("@metaplex-foundation/js");
const spl_token_1 = require("@solana/spl-token");
const addresses_1 = require("./addresses");
const instructions_1 = require("./instructions");
const tokens_1 = require("./tokens");
const util_1 = require("./util");
const xnft_1 = require("./xnft");
const idlErrors = (0, anchor_1.parseIdlErrors)(xnft_1.IDL);
class xNFT {
    /**
     * Creates an instance of xNFT.
     * @param {Provider} provider
     * @memberof xNFT
     */
    constructor(provider) {
        _xNFT_mpl.set(this, void 0);
        _xNFT_program.set(this, void 0);
        _xNFT_provider.set(this, void 0);
        if (!provider.publicKey) {
            throw new Error("no public key found on the argued provider");
        }
        else if (!provider.sendAndConfirm) {
            throw new Error("no sendAndConfirm function found on the argued provider");
        }
        __classPrivateFieldSet(this, _xNFT_mpl, js_1.Metaplex.make(provider.connection), "f");
        __classPrivateFieldSet(this, _xNFT_program, new anchor_1.Program(xnft_1.IDL, addresses_1.PROGRAM_ID, provider), "f");
        __classPrivateFieldSet(this, _xNFT_provider, provider, "f");
    }
    /**
     * Create an instance of the client without a full provider.
     * @static
     * @param {Connection} connection
     * @returns {xNFT}
     * @memberof xNFT
     */
    static anonymous(connection) {
        return new xNFT((0, util_1.buildAnonymousProvider)(connection));
    }
    /**
     * Readonly accessor for the internal Metaplex SDK instance.
     * @readonly
     * @type {Metaplex}
     * @memberof xNFT
     */
    get metaplex() {
        return __classPrivateFieldGet(this, _xNFT_mpl, "f");
    }
    /**
     * Readonly access for the internal program instance.
     * @readonly
     * @type {Program<Xnft>}
     * @memberof xNFT
     */
    get program() {
        return __classPrivateFieldGet(this, _xNFT_program, "f");
    }
    /**
     * Readonly accessor for the internal provider instance.
     * @readonly
     * @type {Provider}
     * @memberof xNFT
     */
    get provider() {
        return __classPrivateFieldGet(this, _xNFT_provider, "f");
    }
    /**
     * Create a standalone application xNFT.
     * @param {CreateXnftAppOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async createAppXnft(opts) {
        var _a, _b, _c, _d, _e, _f;
        const tx = await (0, instructions_1.createCreateAppXnftTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), opts.name, {
            creators: opts.creators,
            curator: (_a = opts.curator) !== null && _a !== void 0 ? _a : null,
            installAuthority: (_b = opts.installAuthority) !== null && _b !== void 0 ? _b : null,
            installPrice: (_c = opts.installPrice) !== null && _c !== void 0 ? _c : new anchor_1.BN(0),
            installVault: (_d = opts.installVault) !== null && _d !== void 0 ? _d : __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey,
            sellerFeeBasisPoints: (_e = opts.sellerFeeBasisPoints) !== null && _e !== void 0 ? _e : 0,
            supply: (_f = opts.supply) !== null && _f !== void 0 ? _f : null,
            symbol: "",
            tag: { [opts.tag]: {} },
            uri: opts.uri,
        });
        return this._withParsedTransactionError(tx);
    }
    /**
     * Create a digital collectible associated xNFT.
     * @param {CreateXnftCollectibleOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async createCollectibleXnft(opts) {
        const tx = await (0, instructions_1.createCreateCollectibleXnftTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), opts.metadata, opts.mint, {
            creators: [],
            curator: null,
            installAuthority: null,
            installPrice: new anchor_1.BN(0),
            installVault: __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey,
            sellerFeeBasisPoints: 0,
            supply: null,
            symbol: "",
            tag: { [opts.tag]: {} },
            uri: opts.uri,
        });
        return this._withParsedTransactionError(tx);
    }
    /**
     * Delete a review for an xNFT that the provider wallet had created.
     * @param {PublicKey} review
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async deleteReview(review, receiver) {
        const tx = await (0, instructions_1.createDeleteReviewTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), review, receiver);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Get the data for the argued xNFT public key and its peripheral accounts.
     * @param {PublicKey} publicKey
     * @returns {Promise<XnftAccount>}
     * @memberof xNFT
     */
    async getAccount(publicKey) {
        const account = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.fetch(publicKey));
        const [tokenAccount, xnftBlob, metadatas] = await Promise.all([
            (0, tokens_1.getNftTokenAccountForMint)(__classPrivateFieldGet(this, _xNFT_provider, "f").connection, account.masterMint),
            __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(account.uri)),
            __classPrivateFieldGet(this, _xNFT_mpl, "f").nfts().findAllByMintList({ mints: [account.masterMint] }),
        ]);
        const md = metadatas[0];
        let mplBlob = {};
        if (!(0, util_1.enumsEqual)(account.kind, "app")) {
            mplBlob = await __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(md.uri));
        }
        return {
            data: account,
            metadata: {
                ...md,
                json: {
                    ...xnftBlob,
                    ...mplBlob,
                },
            },
            publicKey,
            token: {
                address: tokenAccount.publicKey,
                owner: tokenAccount.account.owner,
            },
        };
    }
    /**
     * Gets all of the xNFT accounts and their data for the argued owner public key.
     * @param {PublicKey} owner
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    async getAccountsByOwner(owner) {
        const metadatas = (await __classPrivateFieldGet(this, _xNFT_mpl, "f").nfts().findAllByOwner({ owner }));
        // Early empty return if no metadata accounts were found for the owner
        if (metadatas.length === 0) {
            return [];
        }
        const possibleXnftPdas = metadatas.map(m => (0, addresses_1.deriveXnftAddress)(m.mintAddress));
        const possibleXnftAddresses = possibleXnftPdas.map(a => a[0]);
        const results = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.fetchMultiple(possibleXnftAddresses));
        // Early empty return if all possible xNFT addresses fetched were null
        if (results.every(r => !r)) {
            return [];
        }
        const validXnfts = results.reduce((acc, curr, idx) => {
            if (curr) {
                return [...acc, { account: curr, metadata: metadatas[idx], publicKey: possibleXnftAddresses[idx] }];
            }
            return acc;
        }, []);
        const xnftBlobs = await Promise.all(validXnfts.map(x => __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(x.account.uri))));
        const mplBlobs = await Promise.all(validXnfts.map(x => (0, util_1.enumsEqual)(x.account.kind, "app")
            ? Promise.resolve({})
            : __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(x.metadata.uri))));
        const tokenAccounts = validXnfts.map(x => (0, spl_token_1.getAssociatedTokenAddressSync)(x.account.masterMint, owner));
        const owned = [];
        validXnfts.forEach((x, idx) => {
            owned.push({
                data: x.account,
                metadata: {
                    ...x.metadata,
                    json: {
                        ...xnftBlobs[idx],
                        ...mplBlobs[idx],
                    },
                },
                publicKey: x.publicKey,
                token: {
                    address: tokenAccounts[idx],
                    owner,
                },
            });
        });
        return owned;
    }
    /**
     * Get the installed xNFTs for the argued wallet public key.
     * @param {PublicKey} wallet
     * @returns {Promise<{ install: IdlInstallAccount; xnft: XnftAccount }[]>}
     * @memberof xNFT
     */
    async getInstallations(wallet) {
        const installations = await __classPrivateFieldGet(this, _xNFT_program, "f").account.install.all([
            {
                memcmp: {
                    offset: 8,
                    bytes: wallet.toBase58(),
                },
            },
        ]);
        const items = [];
        for await (const i of installations) {
            const xnft = await this.getAccount(i.account.xnft);
            items.push({
                install: i.account,
                xnft,
            });
        }
        return items;
    }
    /**
     * Get multiple xNFT program accounts and peripheral data based on the optionally
     * provided program account filters.
     * @param {Kind | null} [kind]
     * @param {GetProgramAccountsFilter[]} [filters]
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    async getMultipleAccounts(kind, filters) {
        const xnfts = (await __classPrivateFieldGet(this, _xNFT_program, "f").account.xnft.all(filters));
        const filteredXnfts = kind ? xnfts.filter(x => (0, util_1.enumsEqual)(x.account.kind, kind)) : xnfts;
        const metadatas = (await __classPrivateFieldGet(this, _xNFT_mpl, "f")
            .nfts()
            .findAllByMintList({ mints: filteredXnfts.map(x => x.account.masterMint) }));
        const xnftBlobs = await Promise.all(filteredXnfts.map(x => __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(x.account.uri))));
        const mplBlobs = await Promise.all(filteredXnfts.map((acc, idx) => (0, util_1.enumsEqual)(acc.account.kind, "app")
            ? Promise.resolve({})
            : __classPrivateFieldGet(this, _xNFT_mpl, "f").storage().downloadJson((0, util_1.gatewayUri)(metadatas[idx].uri))));
        const tokenAccounts = await Promise.all(metadatas.map(m => (0, tokens_1.getNftTokenAccountForMint)(__classPrivateFieldGet(this, _xNFT_provider, "f").connection, m.mintAddress)));
        const response = [];
        filteredXnfts.forEach((acc, idx) => {
            response.push({
                data: acc.account,
                metadata: {
                    ...metadatas[idx],
                    json: {
                        ...xnftBlobs[idx],
                        ...mplBlobs[idx],
                    },
                },
                publicKey: acc.publicKey,
                token: {
                    address: tokenAccounts[idx].publicKey,
                    owner: tokenAccounts[idx].account.owner,
                },
            });
        });
        return response;
    }
    /**
     * Get all Review program accounts associated with the argued xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<ProgramAccount<IdlReviewAccount>[]>}
     * @memberof xNFT
     */
    async getReviews(xnft) {
        return __classPrivateFieldGet(this, _xNFT_program, "f").account.review.all([
            {
                memcmp: {
                    offset: 40,
                    bytes: xnft.toBase58(),
                },
            },
        ]);
    }
    /**
     * Grant access to the argued wallet for the xNFT that should be private
     * and being signed by the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async grantAccess(xnft, wallet) {
        const tx = await (0, instructions_1.createGrantAccessTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, wallet);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Install an xNFT for the wallet on the provider.
     * @param {PublicKey} xnft
     * @param {PublicKey} installVault
     * @param {boolean} [permissioned]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async install(xnft, installVault, permissioned) {
        const tx = await (0, instructions_1.createCreateInstallTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, installVault, permissioned);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows a wallet with an active installation of the argued xNFT
     * publish their review content to a program account and leave a
     * 0-5 rating.
     * @param {string} uri
     * @param {number} rating
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async review(uri, rating, xnft, masterToken) {
        const [install] = (0, addresses_1.deriveInstallAddress)(__classPrivateFieldGet(this, _xNFT_provider, "f").publicKey, xnft);
        const tx = await (0, instructions_1.createCreateReviewTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), uri, rating, install, masterToken, xnft);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Remove access from the private xNFT for the argued wallet. Signer of the
     * transaction must be the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async revokeAccess(xnft, wallet) {
        const tx = await (0, instructions_1.createRevokeAccessTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, wallet);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows the authority of an xNFT to begin the curation assignment process.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @param {PublicKey} curator
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async setCurator(xnft, masterToken, curator) {
        const tx = await (0, instructions_1.createSetCuratorTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterToken, curator);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Toggles the suspended field of the xNFT to the argued flag value.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {boolean} value
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async setSuspended(xnft, masterMint, value) {
        const masterToken = (0, spl_token_1.getAssociatedTokenAddressSync)(masterMint, __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey);
        const tx = await (0, instructions_1.createSetSuspendedTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterToken, value);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Transfers ownership and authority of the xNFT to the argued recipient.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {PublicKey} recipient
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async transfer(xnft, masterMint, recipient) {
        const tx = await (0, instructions_1.createTransferTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, masterMint, recipient);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Attempts to update the xNFT's metadata with option signing requirements
     * from a curation entity. All values provided to the options parameter are
     * binding and should be populated with the previous values to be unchanged.
     * @param {PublicKey} masterMint
     * @param {UpdateXnftOptions} opts
     * @param {PublicKey} [curator]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async update(masterMint, opts, curator) {
        var _a, _b, _c, _d;
        const [xnft] = (0, addresses_1.deriveXnftAddress)(masterMint);
        const masterToken = (0, spl_token_1.getAssociatedTokenAddressSync)(masterMint, __classPrivateFieldGet(this, _xNFT_provider, "f").publicKey);
        const tx = await (0, instructions_1.createUpdateXnftTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), {
            installAuthority: (_a = opts.installAuthority) !== null && _a !== void 0 ? _a : null,
            installPrice: opts.installPrice,
            installVault: opts.installVault,
            name: (_b = opts.name) !== null && _b !== void 0 ? _b : null,
            supply: (_c = opts.supply) !== null && _c !== void 0 ? _c : null,
            tag: { [opts.tag]: {} },
            uri: (_d = opts.uri) !== null && _d !== void 0 ? _d : null,
        }, xnft, masterToken, curator);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Delete and remove an installed xNFT from the provider wallet and return
     * the rent lamports to the wallet, or to the argued receiver public key
     * if one is provided.
     * @param {PublicKey} xnft
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async uninstall(xnft, receiver) {
        const tx = await (0, instructions_1.createDeleteInstallTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft, receiver);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Allows a curation authority to verify their assignment on an xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async verify(xnft) {
        const tx = await (0, instructions_1.createVerifyCuratorTransaction)(__classPrivateFieldGet(this, _xNFT_program, "f"), xnft);
        return this._withParsedTransactionError(tx);
    }
    /**
     * Utility function to wrap a transaction execution and parse
     * the resulting logs for any errors.
     * @private
     * @param {Transaction} tx
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    async _withParsedTransactionError(tx) {
        try {
            return await __classPrivateFieldGet(this, _xNFT_provider, "f").sendAndConfirm(tx);
        }
        catch (err) {
            throw (0, anchor_1.translateError)(err, idlErrors);
        }
    }
}
exports.xNFT = xNFT;
_xNFT_mpl = new WeakMap(), _xNFT_program = new WeakMap(), _xNFT_provider = new WeakMap();
//# sourceMappingURL=client.js.map