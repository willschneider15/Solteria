import { Program, type ProgramAccount, type Provider } from "@coral-xyz/anchor";
import { Metaplex } from "@metaplex-foundation/js";
import { PublicKey, Connection, type GetProgramAccountsFilter } from "@solana/web3.js";
import type { CreateXnftAppOptions, CreateXnftCollectibleOptions, IdlInstallAccount, IdlReviewAccount, Kind, UpdateXnftOptions, XnftAccount } from "./types";
import { type Xnft } from "./xnft";
export declare class xNFT {
    #private;
    /**
     * Creates an instance of xNFT.
     * @param {Provider} provider
     * @memberof xNFT
     */
    constructor(provider: Provider);
    /**
     * Create an instance of the client without a full provider.
     * @static
     * @param {Connection} connection
     * @returns {xNFT}
     * @memberof xNFT
     */
    static anonymous(connection: Connection): xNFT;
    /**
     * Readonly accessor for the internal Metaplex SDK instance.
     * @readonly
     * @type {Metaplex}
     * @memberof xNFT
     */
    get metaplex(): Metaplex;
    /**
     * Readonly access for the internal program instance.
     * @readonly
     * @type {Program<Xnft>}
     * @memberof xNFT
     */
    get program(): Program<Xnft>;
    /**
     * Readonly accessor for the internal provider instance.
     * @readonly
     * @type {Provider}
     * @memberof xNFT
     */
    get provider(): Provider;
    /**
     * Create a standalone application xNFT.
     * @param {CreateXnftAppOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    createAppXnft(opts: CreateXnftAppOptions): Promise<string>;
    /**
     * Create a digital collectible associated xNFT.
     * @param {CreateXnftCollectibleOptions} opts
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    createCollectibleXnft(opts: CreateXnftCollectibleOptions): Promise<string>;
    /**
     * Delete a review for an xNFT that the provider wallet had created.
     * @param {PublicKey} review
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    deleteReview(review: PublicKey, receiver?: PublicKey): Promise<string>;
    /**
     * Get the data for the argued xNFT public key and its peripheral accounts.
     * @param {PublicKey} publicKey
     * @returns {Promise<XnftAccount>}
     * @memberof xNFT
     */
    getAccount(publicKey: PublicKey): Promise<XnftAccount>;
    /**
     * Gets all of the xNFT accounts and their data for the argued owner public key.
     * @param {PublicKey} owner
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    getAccountsByOwner(owner: PublicKey): Promise<XnftAccount[]>;
    /**
     * Get the installed xNFTs for the argued wallet public key.
     * @param {PublicKey} wallet
     * @returns {Promise<{ install: IdlInstallAccount; xnft: XnftAccount }[]>}
     * @memberof xNFT
     */
    getInstallations(wallet: PublicKey): Promise<{
        install: IdlInstallAccount;
        xnft: XnftAccount;
    }[]>;
    /**
     * Get multiple xNFT program accounts and peripheral data based on the optionally
     * provided program account filters.
     * @param {Kind | null} [kind]
     * @param {GetProgramAccountsFilter[]} [filters]
     * @returns {Promise<XnftAccount[]>}
     * @memberof xNFT
     */
    getMultipleAccounts(kind?: Kind | null, filters?: GetProgramAccountsFilter[]): Promise<XnftAccount[]>;
    /**
     * Get all Review program accounts associated with the argued xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<ProgramAccount<IdlReviewAccount>[]>}
     * @memberof xNFT
     */
    getReviews(xnft: PublicKey): Promise<ProgramAccount<IdlReviewAccount>[]>;
    /**
     * Grant access to the argued wallet for the xNFT that should be private
     * and being signed by the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    grantAccess(xnft: PublicKey, wallet: PublicKey): Promise<string>;
    /**
     * Install an xNFT for the wallet on the provider.
     * @param {PublicKey} xnft
     * @param {PublicKey} installVault
     * @param {boolean} [permissioned]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    install(xnft: PublicKey, installVault: PublicKey, permissioned?: boolean): Promise<string>;
    /**
     * Allows a wallet with an active installation of the argued xNFT
     * publish their review content to a program account and leave a
     * 0-5 rating.
     * @param {string} uri
     * @param {number} rating
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    review(uri: string, rating: number, xnft: PublicKey, masterToken: PublicKey): Promise<string>;
    /**
     * Remove access from the private xNFT for the argued wallet. Signer of the
     * transaction must be the install authority.
     * @param {PublicKey} xnft
     * @param {PublicKey} wallet
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    revokeAccess(xnft: PublicKey, wallet: PublicKey): Promise<string>;
    /**
     * Allows the authority of an xNFT to begin the curation assignment process.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterToken
     * @param {PublicKey} curator
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    setCurator(xnft: PublicKey, masterToken: PublicKey, curator: PublicKey): Promise<string>;
    /**
     * Toggles the suspended field of the xNFT to the argued flag value.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {boolean} value
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    setSuspended(xnft: PublicKey, masterMint: PublicKey, value: boolean): Promise<string>;
    /**
     * Transfers ownership and authority of the xNFT to the argued recipient.
     * @param {PublicKey} xnft
     * @param {PublicKey} masterMint
     * @param {PublicKey} recipient
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    transfer(xnft: PublicKey, masterMint: PublicKey, recipient: PublicKey): Promise<string>;
    /**
     * Attempts to update the xNFT's metadata with option signing requirements
     * from a curation entity. All values provided to the options parameter are
     * binding and should be populated with the previous values to be unchanged.
     * @param {PublicKey} masterMint
     * @param {UpdateXnftOptions} opts
     * @param {PublicKey} [curator]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    update(masterMint: PublicKey, opts: UpdateXnftOptions, curator?: PublicKey): Promise<string>;
    /**
     * Delete and remove an installed xNFT from the provider wallet and return
     * the rent lamports to the wallet, or to the argued receiver public key
     * if one is provided.
     * @param {PublicKey} xnft
     * @param {PublicKey} [receiver]
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    uninstall(xnft: PublicKey, receiver?: PublicKey): Promise<string>;
    /**
     * Allows a curation authority to verify their assignment on an xNFT.
     * @param {PublicKey} xnft
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    verify(xnft: PublicKey): Promise<string>;
    /**
     * Utility function to wrap a transaction execution and parse
     * the resulting logs for any errors.
     * @private
     * @param {Transaction} tx
     * @returns {Promise<string>}
     * @memberof xNFT
     */
    private _withParsedTransactionError;
}
//# sourceMappingURL=client.d.ts.map