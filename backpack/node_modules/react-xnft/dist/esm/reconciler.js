import ReactReconciler from "react-reconciler";
import { getLogger } from "@coral-xyz/common-public";
import { EventEmitter } from "eventemitter3";
import { NAV_STACK } from "./Context";
import { CONNECT, ETHEREUM_CONNECT, SOLANA_CONNECT } from "./EVENTS";
import { ReactDom } from "./ReactDom";
const logger = getLogger("react-xnft/reconciler");
const events = new EventEmitter();
export const ReactXnft = {
    events,
    render(reactNode) {
        window.addEventListener("load", () => {
            window.xnft.on("connect", () => {
                logger.debug("connect");
                NAV_STACK.push(reactNode);
                events.emit(CONNECT);
            });
            window.xnft.solana.on("connect", () => {
                events.emit(SOLANA_CONNECT);
            });
            window.xnft.ethereum.on("connect", () => {
                events.emit(ETHEREUM_CONNECT);
            });
            window.xnft.on("mount", () => {
                logger.debug("mount");
                const node = NAV_STACK[NAV_STACK.length - 1];
                reconcilerRender(node);
            });
            window.xnft.on("unmount", () => {
                logger.debug("unmount");
            });
            window.xnft.on("pop", () => {
                logger.debug("pop");
                NAV_STACK.pop();
            });
        });
    },
    renderWidget(reactNode) { },
};
//
// Renders the dom in the hosted environment.
//
export function reconcilerRender(reactNode) {
    const cb = () => { };
    const root = {
        host: HOST,
        children: [],
    };
    const container = RECONCILER.createContainer(root, false, false);
    RECONCILER.updateContainer(reactNode, container, null, cb);
}
const RECONCILER = ReactReconciler({
    isPrimaryRenderer: true,
    supportsMutation: true,
    supportsHydration: false,
    supportsPersistence: false,
    now: Date.now,
    noTimeout: -1,
    //
    // Host context configuration.
    //
    getRootHostContext: (root) => {
        logger.debug("getRootHostContext");
        return root.host;
    },
    getChildHostContext: (parentHost, kind, root) => {
        logger.debug("getChildHostContext");
        return parentHost;
    },
    //
    // Create serialized nodes.
    //
    createInstance: (kind, props, r, h, o) => {
        logger.debug("createInstance", kind, props);
        switch (kind) {
            case NodeKind.View:
                return createViewInstance(kind, props, r, h, o);
            case NodeKind.Table:
                return createTableInstance(kind, props, r, h, o);
            case NodeKind.TableRow:
                return createTableRowInstance(kind, props, r, h, o);
            case NodeKind.Text:
                return createTextLabelInstance(kind, props, r, h, o);
            case NodeKind.TextField:
                return createTextFieldInstance(kind, props, r, h, o);
            case NodeKind.Image:
                return createImageInstance(kind, props, r, h, o);
            case NodeKind.Button:
                return createButtonInstance(kind, props, r, h, o);
            case NodeKind.Loading:
                return createLoadingInstance(kind, props, r, h, o);
            case NodeKind.Audio:
                return createAudioInstance(kind, props, r, h, o);
            case NodeKind.Video:
                return createVideoInstance(kind, props, r, h, o);
            case NodeKind.ScrollBar:
                return createScrollBarInstance(kind, props, r, h, o);
            case NodeKind.Svg:
                return createSvgInstance(kind, props, r, h, o);
            case NodeKind.Path:
                return createPathInstance(kind, props, r, h, o);
            case NodeKind.Circle:
                return createCircleInstance(kind, props, r, h, o);
            case NodeKind.Iframe:
                return createIframeInstance(kind, props, r, h, o);
            case NodeKind.NavAnimation:
                return createNavAnimationInstance(kind, props, r, h, o);
            case NodeKind.BalancesTable:
                return createBalancesTableInstance(kind, props, r, h, o);
            case NodeKind.BalancesTableHead:
                return createBalancesTableHeadInstance(kind, props, r, h, o);
            case NodeKind.BalancesTableContent:
                return createBalancesTableContentInstance(kind, props, r, h, o);
            case NodeKind.BalancesTableRow:
                return createBalancesTableRowInstance(kind, props, r, h, o);
            case NodeKind.BalancesTableCell:
                return createBalancesTableCellInstance(kind, props, r, h, o);
            case NodeKind.BalancesTableFooter:
                return createBalancesTableFooterInstance(kind, props, r, h, o);
            case NodeKind.Custom:
                if (!props.component) {
                    throw new Error("Component not found in Custom Node");
                }
                return createCustomInstance(kind, props, r, h, o);
            default:
                throw new Error(`Component ${kind} is not part of the ReactXnft library, please use the available set of components.`);
        }
    },
    createTextInstance: (text, _r, h, _o) => {
        logger.debug("createTextInstance", text);
        const instance = {
            id: h.nextId(),
            kind: "raw",
            text,
        };
        return instance;
    },
    appendInitialChild: (parent, child) => {
        logger.debug("appendInitialChild", parent, child);
        parent.children.push(child);
    },
    //
    // Render phase.
    //
    prepareUpdate: (instance, type, oldProps, newProps, root, host) => {
        logger.debug("prepareUpdate", instance, type, oldProps, newProps);
        return {
            props: newProps,
        };
    },
    finalizeInitialChildren: (_parent, _kind, _props, _root, _host) => {
        logger.debug("finalizeInitialChildren", _parent, _kind, _props, _root, _host);
        return false;
    },
    //
    // Commit phase.
    //
    prepareForCommit: (_c) => {
        logger.debug("prepareForCommit", _c);
        return null;
    },
    commitUpdate: (instance, updatePayload, type, oldProps, newProps, internalInstanceHandle) => {
        logger.debug("commitUpdate", instance, type, updatePayload, oldProps, newProps);
        //
        // If there's no update payload, then don't rerender!
        //
        if (updatePayload === null || Object.keys(updatePayload).length === 0) {
            return;
        }
        instance.props = updatePayload.props;
        ReactDom.getInstance().commitUpdate(instance.id, updatePayload);
    },
    commitTextUpdate: (textInstance, oldText, nextText) => {
        logger.debug("commitTextUpdate");
        textInstance.text = nextText;
        ReactDom.getInstance().commitTextUpdate(textInstance.id, nextText);
    },
    appendChildToContainer: (c, child) => {
        logger.debug("appendChildToContainer", c, child);
        ReactDom.getInstance().appendChildToContainer(child);
    },
    appendChild: (parent, child) => {
        logger.debug("appendChild", parent, child);
        ReactDom.getInstance().appendChild(parent.id, child);
    },
    insertInContainerBefore: (root, child, before) => {
        logger.debug("insertInContainerBefore");
        ReactDom.getInstance().insertInContainerBefore(child, before.id);
    },
    insertBefore: (parent, child, before) => {
        logger.debug("insertBefore");
        ReactDom.getInstance().insertBefore(parent.id, child, before.id);
    },
    removeChild: (parent, child) => {
        logger.debug("removeChild", parent, child);
        ReactDom.getInstance().removeChild(parent.id, child.id);
    },
    removeChildFromContainer: (root, child) => {
        logger.debug("removeChildFromContainer", root, child);
        ReactDom.getInstance().removeChildFromContainer(child.id);
    },
    //
    // Misc.
    //
    getPublicInstance: (instance) => {
        logger.debug("getPublicInstance");
        return instance;
    },
    shouldSetTextContent: () => {
        logger.debug("shouldSetTextContent");
        return false;
    },
    resetAfterCommit: (root) => {
        logger.debug("resetAfterCommit", root);
    },
    clearContainer: (root) => {
        logger.debug("clearContainer", root);
        root.children = [];
    },
    shouldDeleteUnhydratedTailInstances: () => {
        logger.debug("shouldDeleteUnhydratedTailInstances");
    },
    scheduleTimeout: (fn, delay) => {
        logger.debug("scheduleTimeout");
        return setTimeout(fn, delay);
    },
});
function createViewInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.View,
        props: props,
        children: [],
    };
}
function createTableInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Table,
        props: props,
        children: [],
    };
}
function createTableRowInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.TableRow,
        props: props,
        children: [],
    };
}
function createTextLabelInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Text,
        props: props,
        children: [],
    };
}
function createTextFieldInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.TextField,
        props: props,
        children: [],
    };
}
function createImageInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    const src = props.src;
    return {
        id,
        kind: NodeKind.Image,
        props: {
            ...props,
            src,
            children: props.children,
        },
        children: [],
    };
}
function createButtonInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.Button,
        props: props,
        children: [],
    };
}
function createAudioInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.Audio,
        props: props,
        children: [],
    };
}
function createVideoInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.Video,
        props: props,
        children: [],
    };
}
function createLoadingInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.Loading,
        // @ts-ignore
        props,
        children: [],
    };
}
function createScrollBarInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.ScrollBar,
        props: props,
        children: [],
    };
}
function createSvgInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Svg,
        // @ts-ignore
        props: props,
        children: [],
    };
}
function createPathInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Path,
        // @ts-ignore
        props: {
            ...props,
        },
        children: [],
    };
}
function createCircleInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Circle,
        // @ts-ignore
        props: {
            ...props,
        },
        children: [],
    };
}
function createIframeInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Iframe,
        // @ts-ignore
        props: {
            ...props,
        },
        children: [],
    };
}
function createCustomInstance(kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.Custom,
        // @ts-ignore
        props: props,
        children: [],
        component: kind,
    };
}
function createNavAnimationInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.NavAnimation,
        // @ts-ignore
        props: props,
        children: [],
    };
}
function createBalancesTableInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.BalancesTable,
        props: props,
        children: [],
    };
}
function createBalancesTableHeadInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.BalancesTableHead,
        // @ts-ignore
        props: props,
        children: [],
    };
}
function createBalancesTableContentInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.BalancesTableContent,
        props: props,
        children: [],
    };
}
function createBalancesTableRowInstance(_kind, props, _r, h, _o) {
    const id = h.nextId();
    return {
        id,
        kind: NodeKind.BalancesTableRow,
        props: props,
        children: [],
    };
}
function createBalancesTableCellInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.BalancesTableCell,
        props: props,
        children: [],
    };
}
function createBalancesTableFooterInstance(_kind, props, _r, h, _o) {
    return {
        id: h.nextId(),
        kind: NodeKind.BalancesTableFooter,
        props: props,
        children: [],
    };
}
export const HOST = {
    nextId: (() => {
        let id = 0;
        return () => id++;
    })(),
};
export var NodeKind;
(function (NodeKind) {
    //
    // App.
    //
    NodeKind["Table"] = "Table";
    NodeKind["TableRow"] = "TableRow";
    NodeKind["Text"] = "Text";
    NodeKind["TextField"] = "TextField";
    NodeKind["Image"] = "Image";
    NodeKind["View"] = "View";
    NodeKind["Audio"] = "Audio";
    NodeKind["Video"] = "Video";
    NodeKind["Button"] = "Button";
    NodeKind["Loading"] = "Loading";
    NodeKind["ScrollBar"] = "ScrollBar";
    NodeKind["Svg"] = "Svg";
    NodeKind["Path"] = "Path";
    NodeKind["Circle"] = "Circle";
    NodeKind["Iframe"] = "Iframe";
    NodeKind["NavAnimation"] = "NavAnimation";
    //
    // Widget.
    //
    NodeKind["BalancesTable"] = "BalancesTable";
    NodeKind["BalancesTableHead"] = "BalancesTableHead";
    NodeKind["BalancesTableContent"] = "BalancesTableContent";
    NodeKind["BalancesTableRow"] = "BalancesTableRow";
    NodeKind["BalancesTableCell"] = "BalancesTableCell";
    NodeKind["BalancesTableFooter"] = "BalancesTableFooter";
    //
    // Custom
    //
    NodeKind["Custom"] = "Custom";
})(NodeKind || (NodeKind = {}));
const noTimeout = -1;
//# sourceMappingURL=reconciler.js.map